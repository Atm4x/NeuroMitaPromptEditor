# README — DSL-Конструктор промптов  

---

## 0. TL;DR

* DSL — это **препроцессор**, который собирает финальный plain-text-промпт из множества файлов и переменных.  
* Вы **не меняете синтаксис ChatGPT / LLama и т. п.**; движок лишь формирует строку, которую потом отдаёт LLM.  
* В `.txt` лежит в основном текст, в `.script` — логика.  
* Подключение идёт через:  
  * `[<path/file.txt>]` — вставка файла целиком;  
  * `[<path/file.script>]` — выполнить скрипт и вставить результат;  
  * `LOAD TagName FROM "file.txt"` — взять конкретную секцию внутри `file.txt`;  
  * `{{SYS_INFO}}` и другие `{{INSERTS}}` — «переменные-вставки», задаются из Python.  

---

## 1. Что такое DSL и что им **не** является

|            | Это про DSL                                                         | Это **не** про DSL                                     |
|------------|---------------------------------------------------------------------|--------------------------------------------------------|
| **Роль**   | Похоже на препроцессор C или Jinja2: собирает готовый текст.        | Не добавляет «спец-язык» внутрь самого промпта LLM.    |
| **Где живёт** | Выполняется полностью на стороне Python-приложения **до** вызова LLM. | Никакой части DSL не остаётся в итоговом промпте.      |
| **Изменения** | Можно менять структуру файлов, логику ветвления, переменные.     | Не требуется менять «язык» системных подсказок LLM.    |

---

## 2. Базовый Workflow

```
main_template.txt ──┐
                    ├─┬→  [.txt] вставляются «как есть»
                    │ │
                    │ └→  [.script] выполняются → RETURN → текст
                    │
                    ├─→  {{INSERTS}} подставляются из Python (например SYS_INFO)
                    │
                    └─→  результат → 1 строка → отправляется в LLM
```

---

## 3. Типы файлов

### 3.1. `.txt` — текстовые шаблоны  
* Статический текст + плейсхолдеры `[<…>]` + секции `[ #TAG ] … [ /TAG ]`.  
* **Не** исполняют DSL-команды. Слова `SET`, `IF` и т. п. внутри `.txt` — это обычный текст.

### 3.2. `.script` — файлы логики  
* Содержат команды DSL (см. раздел 5).  
* Возвращают строку (`RETURN …`), которая подставляется в место вызова.

---

## 4. Вставки, плейсхолдеры и секции

| Механизм                                   | Синтаксис                              | Что делает                                               |
|--------------------------------------------|----------------------------------------|----------------------------------------------------------|
| **Плейсхолдер** файла / скрипта            | `[<Main/common.txt>]`, `[<Scripts/a.script>]` | Вставляет файл или результат скрипта.                    |
| **Вставки (inserts)**                      | `{{SYS_INFO}}`, `{{PLAYER_NAME}}`      | Заполняются из Python: `interpreter.set_insert()`.       |
| **Секция в .txt**                          | `[ #GREETING ] … [ /GREETING ]`        | Части файла, адресуемые по имени тега.                   |
| **Команда LOAD секции**                    | `LOAD GREETING FROM "Main/main.txt"`   | Берёт только нужную секцию, без маркеров.                |
| **LOAD целого файла**                      | `LOAD "Main/main.txt"`                 | Вставляет файл **целиком**, маркеры `[ #… ]` удаляет.     |
| **Inline-LOAD в выражении**                | `SET msg = LOAD GREET FROM "f.txt" + "!"` | Работает внутри `SET`/`RETURN` как обычная конкатенация. |

---

## 5. Команды DSL (быстрый справочник)

```
SET var = <expr>                     # присвоение
LOG <expr>                           # вывод в логи
IF / ELSEIF / ELSE / ENDIF           # условные блоки
RETURN <expr | LOAD ... | LOAD_REL ...>
```

* `<expr>` — обычное Python-подобное выражение (строки, числа, +, f-строки).  
* Внутри `<expr>` можно писать **inline-LOAD** — см. выше.  

---

## 6. Правила поиска файлов

1. `_CommonPrompts/` и `_CommonScripts/` — общие папки.  
2. `./` и `../` — относительно текущего файла.  
3. Остальные пути — относительно папки персонажа.  
4. Безопасность: нельзя «вырваться» из `Prompts/` (см. код `secure_join`).

---

## 7. Мини-пример

```
Prompts/
└── Hero/
    ├── main_template.txt
    ├── Main/
    │   └── hero_core.txt
    ├── Scripts/
    │   └── build_mood.script
    └── Context/
        └── examples.txt
```

### main_template.txt
```text
[<Main/hero_core.txt>]

[#DIALOGUE]
[<Context/examples.txt>]
[/DIALOGUE]

Current mood:
[<Scripts/build_mood.script>]

{{SYS_INFO}}
```

### build_mood.script
```dsl
IF bravery > 50
    RETURN "Fearless"
ELSE
    RETURN "Cautious"
ENDIF
```

Python-код:
```python
interp = DslInterpreter(hero_character)
interp.set_insert("SYS_INFO", "[SYSTEM]: demo run")
prompt = interp.process_main_template_file("main_template.txt")
print(prompt)
```

---

## 8. Советы

* Используйте `LOG` для отладки, логи смотрите в `Logs/dsl_execution.log`.  
* Держите длинные тексты в `.txt`, логику — в `.script`.  
* Общие куски складывайте в `_CommonPrompts` / `_CommonScripts`.  
* Не забудьте добавить `{{SYS_INFO}}` хотя бы один раз — редактор предупредит, если его нет.

---

## 9. Часто задаваемые вопросы

| Вопрос                                            | Ответ |
|---------------------------------------------------|-------|
| «Нужно ли включать DSL-команды в окончательный промпт?» | Нет, все команды обрабатываются до отправки в модель. |
| «Можно ли писать несколько `LOAD … FROM …` в одной строке?» | Да, благодаря inline-LOAD: `RETURN LOAD A FROM "f.txt" + LOAD B FROM "f.txt"` |
| «Почему в `.txt` не подсвечиваются `SET` и `IF`?» | В `.txt` это обычный текст; подсветка DSL включена только для `.script`. |
| «Как вставить пустую строку перед `[/TAG]`?»      | Просто оставьте её — `_extract_tag_section` сохраняет такие переводы строки. |

---

Happy Prompt-Building!